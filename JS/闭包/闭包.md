# 闭包
```
function a(){
    let a =1;
    function b(){
        console.log(a);
    }
    return b;
}

var closure = a();  // 引用
closure();   // 1
```
a的作用域在`a()`里面

一般，函数体内定义的变量在函数体外是无法访问的；

#### 一、闭包是什么？
1.肯定是个函数。能读取其他函数内部变量的函数； `b()`
2.函数在其定义的作用域以外进行访问时，产生闭包

#### 二、闭包怎么产生？
`var closure = a(); `将`b()`的引用指向closure，这是【引用赋值】，阻止垃圾回收机制将`a()`进行回收，从而导致整条作用域链都被保存下来了；
当函数`closure()`执行的时候，闭包才形成；

#### 三、闭包是谁？
chrome判断`a()`是闭包；

#### 四、闭包的应用

```
for (var i = 0; i < 5; i++) {
    ((j) => {
        setTimeout(() => {
            console.log(j);
        }, 1000 * j)
    })(i)
}
```
###### 利用立即执行函数，为每次循环创建一个单独的作用域；


这里面的`(j)`是起到【引用赋值】的作用吗？指向的是定时器吗？
是因为它阻止了垃圾回收机制将`a()`回收的吗?

这段代码中的闭包是谁？是定时器吗？还是一整个for循环


#### 五、闭包的使用事项
相关概念——`垃圾回收机制`：

内存泄漏（Memory Leak)JavaScript分配给Web浏览器的可用内存数量通常比分配给桌面应用程序的少，这样做主要是防止JavaScript的网页耗尽全部系统内存而导致系统崩溃。

因此，要想使页面具有更好的性能，就必须确保页面占用最少的内存资源，也就是说，我们应该保证执行代码只保存有用的数据，一旦数据不再有用，我们就应该让垃圾回收机制对其进行回收，释放内存。

闭包阻止垃圾回收机制对变量进行回收，导致变量会永远存在内存中。容易造成内存泄漏，影响页面的性能。因此，当页面不再适用时，要将其释放；

```
function a(){
    let a =1;
    function b(){
        console.log(a);
    }
    return b;
}

var closure = a();  // 引用
closure();   // 1

// 如果不用了,释放掉
closure = null;
```

