# 闭包

```text
function a(){
    let a =1;
    function b(){
        console.log(a);
    }
    return b;
}

var closure = a();  // 引用
closure();   // 1
```

a的作用域在`a()`里面

一般，函数体内定义的变量在函数体外是无法访问的；

## 一、闭包是什么？

1.肯定是个函数。能读取其他函数内部变量的函数； `b()` 2.函数在其定义的作用域以外进行访问时，产生闭包

## 二、闭包怎么产生？

`var closure = a();`将`b()`的引用指向closure，这是【引用赋值】，阻止垃圾回收机制将`a()`进行回收，从而导致整条作用域链都被保存下来了； 当函数`closure()`执行的时候，闭包才形成；

## 三、闭包是谁？

chrome判断`a()`是闭包；

## 四、闭包的应用

```text
for (var i = 0; i < 5; i++) {
    ((j) => {
        setTimeout(() => {
            console.log(j);
        }, 1000 * j)
    })(i)
}
```

### 利用立即执行函数，为每次循环创建一个单独的作用域；

这里面的`(j)`是起到【引用赋值】的作用吗？指向的是定时器吗？ 是因为它阻止了垃圾回收机制将`a()`回收的吗?

这段代码中的闭包是谁？是定时器吗？还是一整个for循环

## 五、闭包的使用事项

相关概念——`垃圾回收机制`：

内存泄漏（Memory Leak\)JavaScript分配给Web浏览器的可用内存数量通常比分配给桌面应用程序的少，这样做主要是防止JavaScript的网页耗尽全部系统内存而导致系统崩溃。

因此，要想使页面具有更好的性能，就必须确保页面占用最少的内存资源，也就是说，我们应该保证执行代码只保存有用的数据，一旦数据不再有用，我们就应该让垃圾回收机制对其进行回收，释放内存。

闭包阻止垃圾回收机制对变量进行回收，导致变量会永远存在内存中。容易造成内存泄漏，影响页面的性能。因此，当页面不再适用时，要将其释放；

```text
function a(){
    let a =1;
    function b(){
        console.log(a);
    }
    return b;
}

var closure = a();  // 引用
closure();   // 1

// 如果不用了,释放掉
closure = null;
```

